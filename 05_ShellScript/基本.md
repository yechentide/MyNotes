# ShellScriptの基本

## 基本設定

### ファイル名

シェルスクリプトファイルは基本的に`.sh`の拡張子で作成

### ファイルの１行目

`#!/bin/sh`と書いて、システムにこれからシェルスクリプトを書きますようと知らせる

ただし、bash の独自機能を使う場合は `#!/bin/bash` と書かなければならない

### 実行の仕方

```shell
./test.sh		# ファイル権限の実行権を設定する必要がある
zsh test.sh
```

### 終了

`exit 0`と書いて、正常に終了したを知らせることもできる

### セミコロン

基本的に行尾にセミコロンをつける必要がないけど、

まとめて１行にするときに`;`で区切る

## 基本コマンド

### コメント

`#`で始まる行はコメントになる

```shell
# コメント
```

### 出力・入力

`echo`で出力、 `read`で入力

```shell
read NAME
echo "Hello, $NAME!"
```

Bash では`-e`フラグで特殊テキストをエスケープできる

```shell
echo -e "Hello\n$NAME!"		#改行される
```

入力を待っている時、スクリプトが続かない

```shell
read NAME
echo "Hello, $NAME!"
```

### 選択させる

```shell
select option in CODE DIE
do
	echo "you pressed ${option}"
	break
done

# 1) CODE
# 2) DIE
# #? 2
# you pressed DIE
```

### ファイルを読み込む

ファイルを引数として渡す

```shell
./readFile.sh data.txt

# readFile.sh
i=1
while read line #受け取ったデータを１行ずつ処理↲
do
	echo "${i}: ${line} "
	i=`expr $i + 1`
done <$1		#第一引数の指定
```

#### splitみたいな機能

IFSはシェル変数で文字列を分割する区切り文字が設定されている

デフォルトは半角スペース、タブ、改行となる

```shell
# 半角スペース区切り
while read c1 c2
do
  echo "$c1 + $c2 = $((c1 + c2))"
done < input.txt

# カンマ区切り：IFSで区切り文字を指定
while IFS=, read c1 c2
do
  echo "$c1 + $c2 = $((c1 + c2))"
done < input.txt
```



### シングルクォート＆ダブルクォート

* シングルクォート：

     `'...'` で囲まれた文字は、パラメータ展開やコマンド置換は行われない、エスケープも使えない

* ダブルクォート：

    `"..."` で囲まれた文字は、パラメータ展開やコマンド置換が行われるし、エスケープキャラクタを使える

    ```shell
    $ message="World"
    $ echo "Hello ${message}!"
    Hello World
    $ echo "$(date "+%Y/%m/%d/%H:%M")"
    2019/04/28
    ```

### 変数

### 

- 変数の名前として、半角英数字とアンダーバーが使える
- 変数に値を与える時`=`を==前後空白なし==で書く
- 文字列の場合は`"`で囲む（`'`は変数展開されない）
- 変数をアクセスする時変数名の前に`$`を入れる。あるいは`$`入れて変数を`{}`で囲む
- 一つの変数に一つの値しか保存できない
- 変数の値を上書きされないようには`readonly`を使う
- 変数を`unset`で削除することができる（`readonly`変数を削除することができません。）
- ローカル変数を使いたいとき、変数名の前に`local`をつける（`local x=10`）

```shell
var="これは変数です"
VaR_2="これも変数です"
echo "Var_2=$VaR_2"

VaR_2="VaR_2が変更されました。"
echo ${VaR_2}

readonly var
var="readonly varを変えてみる。"
```

### 特別な変数

* `$0`：スクリプト名
* `$1`〜`$9`：１〜９番目の引数
* `$#`：スクリプトに与えた引数の数
* `$*`：全部の引数をまとめて1つとして処理
* `$@`：全部の引数を個別として処理
* `$?`：直前実行したコマンドの終了値（0は成功、1は失敗）
* `$$`：このシェルスクリプトのプロセスID
* `$!`：最後に実行したバックグラウンドプロセスID

```shell
#!/bin/sh

echo "\$0（スクリプト名）: $0"
echo "\$1（1番目の引数）: $1"
echo "\$2（2番目の引数）: $2"
echo "\$#（引数の数）: $#"
echo "\"\$*\": \"$*\""
echo "\"\$@\": \"$@\""
VAR="exit値は0になるはずです"
echo $?
```

### 特殊文字

スクリプトで、特殊文字として認識される文字は、`\`を書いてから使う

```plain
* ? [ ' " ` \ $ ; & ( ) | ~ < > # % = スペース タブ 改行
```

### 変数値の置換

* `${var}`：変数値を入れ替える
* `${var:-word}`：変数がセットされていないor空文字列のとき、wordを返す。変数varに保存しない
* `${var:=word}`：変数がセットされていないor空文字列のとき、wordを返す。変数varに保存する
* `${var:?word}`：変数がまだセットされていないか空文字列の場合置換に失敗し、スタンダードエラーにエラーを表示
* `${var:+word}`：変数がセットされているとき、wordを返す。変数varに保存しない

### 配列

```shell
#bash shellで配列の書き方
Array=(item1 item2 item3 item4)
Array[0]="ITEM1"
Array[2]="ITEM3"

echo "Array[0]: ${Array[0]}"
echo "Array[1]: ${Array[1]}"

#全てのアイテムをアクセスする
echo "Array[*]: ${Array[*]}"
echo "Array[@]: ${Array[@]}"

#要素数
echo ${#Array[@]}
```

### オペレータ

算術演算子を  \`expr 数字 演算子 数字\`  で計算できる

==`[` コマンドの引数に変数を指定するときは `"` でクォートする必要がある==

```shell
echo `expr 10 + 20`
echo `expr 20 - 10`
echo `expr 11 \* 11`
echo `expr 10 / 2`
echo `expr 10 % 4`
```

* `a=$b`：bの値はaに保存

#### 比較演算子

* `[ "$a" -eq "$b" ]`：イコール
* `[ "$a" -ne "$b" ]`：異なる
* `[ "$a" -gt "$b" ]`：より大きい
* `[ "$a" -lt "$b" ]`：より小さい
* `[ "$a" -ge "$b" ]`：より大きいか同じか
* `[ "$a" -le "$b" ]`：より小さいか同じか

#### 論理演算子

* `-a`：and
* `-o`：or
* `[ ! "$a" -gt "$b" ]`：否定

#### 文字列に対する演算子

* `[ "$a" == "$b" ]`：\$aと​\$bが同じ場合TRUEを返す
* `[ "$a" != "$b" ]`：\$aと\$bが同じではない場合TRUEを返す
* `[ -z "$a" ]`：文字列が空か（指定がある場合はTRUE）
* `[ -n "$a" ]`：文字列が空か（指定がある場合はTRUE）

#### ファイルに対する演算子

* `-nt`：newer than
* `-ot`：older than
* `-e`：
* `-d`：

## 制御構文

### test

```shell
[ 1 -eq 2 ]
echo $?		# 1
test 1 -eq 2
echo $?		# 1
test 1 -eq 1;
echo $?		# 0
```

### if

基本の書き方は `if [ 条件 ] then コマンド fi` 

```shell
if [ "$1" -gt "$2" ]
then 
    echo "1番目の引数が2番目の引数より大きい"
elif [ "$1" -eq "$2" ]; then
    echo "1番目の引数と2番目の引数は同じです"
else
    echo "1番目の引数が2番目の引数より小さい"
fi
```

### case

基本の書き方は `case 変数 in 条件・値) コマンド ;; esac`

```shell
DRINK="coffee"
case "$DRINK" in
    "beer") echo "ビールです" 
    ;;
    "juice")
    echo "ジュースです" 
    ;;
    "coffee") echo "プログラマーが飲むとコードに変化！" 
    ;;
    *)
    echo "..."
    ;;
esac
```

### while

条件が合うときループ

`break` `continue`キーワードを使える

```shell
a=0
while [ $a -lt 5 ]
do
    echo $a
    a=`expr $a + 1`
done

# 無限ループ
while :
do
	# ......
done
```

### until

whileの逆、条件が合うまでループ

`break` `continue`キーワードを使える

```shell
a=0
until [ ! $a -lt 5 ]
do
    echo $a
    a=`expr $a + 1`
done
```

### for

基本の書き方は `for 変数 in 複数値・変数・範囲 do コマンド done`

`break` `continue`キーワードを使える

```shell
for var in 0 1 2 3 4  #範囲の書き方(Bash独自) => {0..4}
do
    echo $var
done

a=(1 2 3 4 5)
for i in ${a[@]}
do
	echo ${i}
done

# 省略形
for i in `seq 1 5`
do
	echo ${i}
done

# 別の形のfor
for (( i=0; i<5; i++ )); do echo $i; done
for (( i=0; i<5; i++ ))
do
  echo $i
done

# ディレクトリの一覧
for dir in `find $(pwd) -mindepth 1 -type d`; do echo $dir; done
```

## 関数

シェルスクリプトでは、関数を書いて引用することができる

キーワード`function`は省略可能

```shell
#関数を指定します
function MyFunction () { 
    echo "関数のechoです。"
}
function MyParamFunc() {
    echo "引数1:$1 引数2:$2"
}

#関数を呼び出します
MyFunction
MyParamFunc param1 param2
```

## 参考サイト

[初心者向けシェルスクリプトの基本コマンドの紹介](https://qiita.com/zayarwinttun/items/0dae4cb66d8f4bd2a337)

[シェルスクリプトBash入門](https://qiita.com/ebisennet/items/573618ab827ce1660b0e)

[★Bashシェルスクリプトの書き方（基本）のおさらいメモ](https://qiita.com/rubytomato@github/items/173a812d7a8ec4646955)

[Bashの便利な構文だがよく忘れてしまうものの備忘録](https://qiita.com/Ping/items/57fd75465dfada76e633)

[Shell Scriptの基本](https://qiita.com/tsukasa_wear_parker/items/c129541654308f0ee505)

[プログラマーの君！ 騙されるな！ シェルスクリプトはそう書いちゃ駄目だ！！ という話](https://qiita.com/piroor/items/77233173707a0baa6360)

[初心者向け、「上手い」シェルスクリプトの書き方メモ](https://qiita.com/m-yamashita/items/889c116b92dc0bf4ea7d)



