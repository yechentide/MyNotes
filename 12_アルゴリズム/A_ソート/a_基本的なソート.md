# 基本的なソート

## バブルソート(bubble sort)

### 計算量

O(n^2^)

### 説明

配列の後ろから先頭に向かって走査していき，

もし隣り合う2つの要素の大小関係が逆であれば，それを入れ換える

## 選択ソート(selection sort)

### 計算量

O(n^2^)

### 説明

「ソートされていない部分から最小の要素を選び出して，それを先頭へ移動する」という手順を繰り返す

## 挿入ソート(insertion sort)

### 計算量

O(n^2^)

### 説明

配列の一部分をソート済みの状態にしておき，残りの要素を一つずつその中の適切な位置に挿入していく

## クイックソート(quick sort)

### 計算量

O(nlog n)

**ソートアルゴリズムの中でも最速の部類**

クイックソートが最も高速に実行されるのは，分割を行った結果，==ピボットの要素がちょうど真ん中に位置するような場合==です． 

反対に，ピボットが端に来るような分割が続くと，クイックソートはかなり効率が悪くなります． 

皮肉なことに，あらかじめ整列されている配列をソートさせると，クイックソートの効率は最悪となり，計算量はO(n^2^)になります．

### 説明

n個の要素a[0], …, a[n-1]を持つ配列aをソートすることを考えましょう． 

まず，ある適当な要素を1個選び出し，これを要素xとします． 

それを最終的に置かれるべき位置a[v]に移動します． 

この要素xのことをピボット（pivot，枢軸）と呼びます． 

この時，xより大きな要素はa[v]より右に，xより小さな要素はa[v]より左へと振り分けます．

1. a[v]よりも小さい要素 a[0], a[1], …, a[v-1]
2. a[v]
3. a[v]よりも大きな要素 a[v+1], a[v+2], …, a[n-1]

a[v]よりも左側にはa[v]よりも小さな要素，右側にはa[v]よりも大きな要素なので，

それぞれの部分についてソートを行えば，配列a全体のソートが完了します． 

この時，1や3の部分についても，いま説明した方法で3分割することを再帰的に行います．

> このような，大きな問題を複数の小さな問題に分割して，それぞれを解いていく方法は，
>
> **分割統治法（divide-and-conquer method）**と呼ばれ，アルゴリズムのテクニックの1つです．

## マージソート(merge sort)

### 計算量

O(nlog n)

**ソートアルゴリズムの中でも最速の部類**

マージソートは定数係数が大きいため，同じO(nlog n)でも、クイックソートには太刀打ちできません．

 しかしながら，マージソートは他のソートアルゴリズムとは違い，要素をシーケンシャルアクセスしてソートするという特徴があります．

マージソートは常にO(nlog n)の計算量でソートできることが保証されています．

### 説明

1. データ列を真ん中で2つの部分列a, bに分割する
2. 部分列a, bをそれぞれソートする
3. ソート済になった部分列a, bをマージする

> これも**分割統治法**を利用している

## ビンソート

### 計算量

データの個数をnn，用意したビンの個数をmmとして、

O(m+n)

用意したビンの個数mmがデータの個数nnに比べて極端に大きい場合を除けば，

ビンソートに必要な計算量はO(n)とみなすことができます．

### 説明

比較によらないソートアルゴリズムの１つである。

ある範囲内に収まっている整数（例えば，0～100の整数）を整列することを考えます．

整列の対象となる整数は重複していないものとします．

1. データが取りうる値の種類の数と同数のビンを用意し，それぞれのビンにデータの値に対応する名前を付けておく
2. 整列対象となるデータを1つずつ順に，対応する名前のビンに入れていく
3. すべてのデータをビンに入れ終えた時点で，ビンの中身を順番に取り出して並べる

キーの範囲が広すぎる場合、ビンソートは実用的ではありません。

ビンソートの領域計算量はO(n)とみなせます。

ビンソートは計算量がO(n)と高速である反面，データの量に比例する作業領域が必要となります．

時間と空間のトレードオフということができます．

キーの大小比較を利用するアルゴリズムの計算量の限界O(nlog n)を超える代償として，大きな作業領域が必要になるわけです．

ビンソートの2つの弱点：

1. キーの重複が許されない．：
    連結リストなどを使用し，ビンに複数のデータが入るようにすれば解決可能．

    なお，分布数え上げソートは，連結リストを使用せずに重複したキーをソート可能．

2. キーはある範囲に収まる整数でなければならない（実用上，その範囲はかなり狭い必要有）：
    分布数え上げソートも同様の制約を受ける．基数ソートアルゴリズムでは，この制約を逃れることが可能