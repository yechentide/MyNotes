## 未分類



### グローバル解決演算子

グローバル変数と同じ名前を持つローカル変数が存在する時、

`::変数名`でグローバル変数を使える



### 記憶寿命

グローバル変数はプログラムの実行準備時から終了まで

ローカル変数は宣言されてから関数が終了するまで

`static`つきローカル変数はグローバル変数の寿命と同じ

* 通常のローカル変数へのポインタや参照を戻り値としてはいけない



### 動的メモリの確保＆解放

限りのあるメモリを必要な時にだけ利用する

```c++
ポインタ = new 型;

int *pA = new int;
*pA = 50;
```

```c++
delete ポインタ;

delete pA;
```

特に配列を扱う時、この方法は重要である

```c++
ポインタ = new 型[要素数];
delete[] ポインタ;
```



### ファイルの分割

* myfunc.h

   ```c++
   // 関数のプロトタイプ宣言
   戻り値の型 関数名(型 仮引数名, 型 仮引数名, ...);
   ```

* myfunc.cpp

   ```c++
   // 関数の定義
   戻り値の型 関数名(型 仮引数名, 型 仮引数名, ...){
      // ...
      return 戻り値;
   }
   ```

* Sample.cpp

   ```c++
   #include <iostream>
   #include "myfunc.h"	// ヘッダファイルを読み込む
   using namespace std;
   
   int main(){
      // 関数を呼び出す
      return 0;
   }
   ```

変数のスコープ：

* ローカル変数：ブロック内
* グローバル変数＆関数：全てのファイル
* `static`付きグローバル変数＆関数：ファイル内



### 名前空間

名前空間によって、変数・関数のスコープを名前空間に限定することができる

```c++
namespace 名前{
   変数宣言;
   関数宣言;
}
```

名前空間の外部から、名前空間の中の変数・関数を使う場合

```c++
名前空間名::変数
名前空間名::関数
```

名前空間名をつけるのが煩わしいとき、`using`文を使う

```c++
using 名前空間名::変数;
using namespace 名前空間名;
```














