# 振る舞いに関するパターン

## Chain of Responsibility

イベントの送受信を行う複数のオブジェクトを鎖状につなぎ、それらの間をイベントが渡されてゆくようにする。

## Command

複数の異なる操作について、それぞれに対応するオブジェクトを用意し、オブジェクトを切り替えることで、操作の切替えを実現する。

## Interpreter

構文解析のために、文法規則を反映するクラス構造を作る。

## Iterator - 1つ1つ数え上げる

### Iteratorパターン

複数の要素を持つオブジェクトのすべての要素に対して、順番にアクセスするためのものである。 iterator は*反復子*と呼ばれる。

### メリット

コンテナオブジェクトの要素を列挙する手段を独立させることによって、コンテナの内部仕様に依存しない反復子を提供できる。

Iterator を使うことで、 実装とは切り離して、 数え上げを行うことができ、再利用化を促進できる。

### Iteratorのメソッド

`hasNext()`と`next()`の２種類のメソッドを用意するのが一般的である

### 色々なIterator

- 最後尾から開始して逆方向に進む
- 順方向にも逆方向にも行く (next メソッドだけでなく previous メソッドも持つ)
- 番号を指定して、いきなりそこにジャンプする

## Mediator

オブジェクト間の相互作用を仲介するオブジェクトを定義し、オブジェクト間の結合度を低くする。

## Memento

データ構造に対する一連の操作のそれぞれを記録しておき、以前の状態の復帰または操作の再現が行えるようにする。

## Observer

インスタンスの変化を他のインスタンスから監視できるようにする。Listenerとも呼ばれる。

## State

オブジェクトの状態を変化させることで、処理内容を変えられるようにする。

## Strategy

データ構造に対して適用する一連のアルゴリズムをカプセル化し、アルゴリズムの切替えを容易にする。

## Template Method - 具体的な処理をサブクラスにまかせる

### Wikiの説明

あるアルゴリズムの途中経過で必要な処理を抽象メソッドに委ね、その実装を変えることで処理が変えられるようにする。

### Template Methodパターン

Template Method パターンの目的は、ある処理のおおまかなアルゴリズムをあらかじめ決めておいて、

そのアルゴリズムの具体的な設計をサブクラスに任せることである。

そのため、システムのフレームワークを構築するための手段としてよく活用される。

### 実装例

スーパークラス内に==抽象メソッドを利用して実際の処理を記述==し、テンプレートとなるメソッドを定義

利用される抽象メソッドは、サブクラスでその処理を定義する

### メリット

* ロジックが共通化できる

    スーパクラスのテンプレートメソッドでアルゴリズムが記述されているので、

    サブクラス側ではアルゴリズムをいちいち記述する必要がなくなる。

    また、テンプレートメソッドに誤りが発見された場合でも、テンプレートメソッドさえ修正すればよいということになる。

* スーパクラスとサブクラスの連携プレー

    スーパクラスで宣言されている抽象メソッドを実際にサブクラスで実装する時には、そのメソッドがどういうタイミングで呼び出されるかを理解しておく必要がある。スーパクラスのソースコードがないと、サブクラスの実装は難しい可能性がある。

* サブクラスをスーパクラスと同一視する

    スーパクラス型の変数があり、その変数にサブクラスのインスタンスが代入されている。このような場合に、instanceof などでサブクラスの種類を特定せずにプログラムが動くようにプログラミングすることはよい。スーパクラス型の変数に、サブクラスのインスタンスのどれを代入しても正しく動作するようにする、という原則は The Liskov Substitution Principle (LSP) と呼ばれている。このLSPは、Template Method パターンに限らない、継承の一般的な原則である。

### デメリット

骨組みを定義するスーパークラスと、実際の処理を定義するサブクラスを両方見ないと、全体の動作が理解できない

### 

## Visitor

データ構造を保持するクラスと、それに対して処理を行うクラスを分離する。