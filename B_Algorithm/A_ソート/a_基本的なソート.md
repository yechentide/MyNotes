# 基本的なソート

## ソート

ソート(整列、sorting)とは、レコードの集まりをキーの値の大小関係に従って並べ換える操作である。

- 昇順：キーが小さいものから大きなものへと、単調増加になるように並べる
- 降順：キーが大きなものから小さなものへと、単調減少になるように並べる

ソートアルゴリズムは、n個のレコードをソートするのに、==最小でもO(nlog n)の計算量が必要==となることが証明されている。

### 比較回数と交換回数

交換の対象となるデータが大きければ、計算量が同じアルゴリズムでも、交換の回数が少ないものを選ぶべきだ。  
逆に比較にコストがかかるならば、計算量が同じアルゴリズムでも、できるだけ比較の回数が少ないものを選ぶべきだ。

### 定数項部分

高速なアルゴリズムは技巧をこらして処理が複雑になる傾向があり、 単純なアルゴリズムに比べて計算量の定数項部分が大きくなる。  
そのため、対象となるレコード数があまり多くなければ、 高速なアルゴリズムよりも単純なアルゴリズムのほうが処理が速いことがある

### 安定なソート

同じキーのソート前の順序が、ソート後も同じになるようなソートアルゴリズムである。  
一方、安定でないアルゴリズムでは、ソート前の位置関係は保存ないが、常に位置関係が保たれないわけでもない。  
一般に、単純な（遅い）アルゴリズムは安定で、複雑な（高速な）アルゴリズムは安定でないという傾向がある（例外もある）。

### 内部ソートと外部ソート

- `内部ソート(internal sorting)`：ソートされるデータの格納領域(メモリ)上で並び替えを進めるソートアルゴリズム
- `外部ソート(external sorting)`：ソートされるデータの格納領域以外に同等以上の記憶領域を必要とするソートアルゴリズム  
    例：マージソート

## バブルソート(bubble sort)

### 計算量

O(1)  <  O(log n)  <  O(n)  <  O(nlog n)  <  ==O(n^整数^)==  <  O(整数^n^)

### 説明

配列の後ろから先頭に向かって走査していき、  
もし隣り合う2つの要素の大小関係が逆であれば、それを入れ換える

## 選択ソート(selection sort)

### 計算量

O(1)  <  O(log n)  <  O(n)  <  O(nlog n)  <  ==O(n^整数^)==  <  O(整数^n^)

### 説明

「ソートされていない部分から最小の要素を選び出して、それを先頭へ移動する」という手順を繰り返す

## 挿入ソート(insertion sort)

### 計算量

O(1)  <  O(log n)  <  O(n)  <  O(nlog n)  <  ==O(n^整数^)==  <  O(整数^n^)

### 説明

配列の一部分をソート済みの状態にしておき、残りの要素を一つずつその中の適切な位置に挿入していく

## クイックソート(quick sort)

### 計算量

O(1)  <  O(log n)  <  O(n)  <  ==O(nlog n)==  <  O(n^整数^)  <  O(整数^n^)

**ソートアルゴリズムの中でも最速の部類**  
クイックソートが最も高速に実行されるのは、分割を行った結果、==ピボットの要素がちょうど真ん中に位置するような場合==である  
反対に、ピボットが端に来るような分割が続くと、クイックソートはかなり効率が悪くなる  
皮肉なことに、あらかじめ整列されている配列をソートさせると、クイックソートの効率は最悪となり、計算量はO(n^2^)になる

### 説明

n個の要素a[0], …, a[n-1]を持つ配列aをソートすることを考えよう  
まず、ある適当な要素を1個選び出し、これを要素xとする  
それを最終的に置かれるべき位置a[v]に移動する  
この要素xのことをピボット（pivot、枢軸）と呼ぶ  
この時、xより大きな要素はa[v]より右に、xより小さな要素はa[v]より左へと振り分ける

1. a[v]よりも小さい要素 a[0], a[1], …, a[v-1]
2. a[v]
3. a[v]よりも大きな要素 a[v+1], a[v+2], …, a[n-1]

a[v]よりも左側にはa[v]よりも小さな要素、右側にはa[v]よりも大きな要素なので、  
それぞれの部分についてソートを行えば、配列a全体のソートが完了する  
この時、1や3の部分についても、いま説明した方法で3分割することを再帰的に行う

> このような、大きな問題を複数の小さな問題に分割して、それぞれを解いていく方法は、
> **分割統治法（divide-and-conquer method）**と呼ばれ、アルゴリズムのテクニックの1つである

## マージソート(merge sort)

### 計算量

O(1)  <  O(log n)  <  O(n)  <  ==O(nlog n)==  <  O(n^整数^)  <  O(整数^n^)

**ソートアルゴリズムの中でも最速の部類**  
マージソートは定数係数が大きいため、同じO(nlog n)でも、クイックソートには太刀打ちできない  
 しかしながら、マージソートは他のソートアルゴリズムとは違い、要素をシーケンシャルアクセスしてソートするという特徴がある  
マージソートは常にO(nlog n)の計算量でソートできることが保証されている

### 説明

1. データ列を真ん中で2つの部分列a, bに分割する
2. 部分列a, bをそれぞれソートする
3. ソート済になった部分列a, bをマージする

> これも**分割統治法**を利用している

## ビンソート

### 計算量

O(1)  <  O(log n)  <  ==O(n)==  <  O(nlog n)  <  O(n^整数^)  <  O(整数^n^)

データの個数をn、用意したビンの個数をmとして、  
O(m+n)  
用意したビンの個数mがデータの個数nに比べて極端に大きい場合を除けば、  
ビンソートに必要な計算量はO(n)とみなすことができ、O(nlog n)の壁を越えられた。

### 説明

==比較によらないソートアルゴリズムの１つである==  
ある範囲内に収まっている整数（例えば、0～100の整数）を整列することを考える  
整列の対象となる整数は重複していないものとする

1. データが取りうる値の種類の数と同数のビンを用意し、それぞれのビンにデータの値に対応する名前を付けておく
2. 整列対象となるデータを1つずつ順に、対応する名前のビンに入れていく
3. すべてのデータをビンに入れ終えた時点で、ビンの中身を順番に取り出して並べる

キーの範囲が広すぎる場合、ビンソートは実用的ではない  
ビンソートの領域計算量はO(n)とみなせる  
ビンソートは計算量がO(n)と高速である反面、データの量に比例する作業領域が必要となる  
時間と空間のトレードオフということができる  
キーの大小比較を利用するアルゴリズムの計算量の限界O(nlog n)を超える代償として、大きな作業領域が必要になるわけである  
ビンソートの2つの弱点：

1. キーの重複が許されない：  
    連結リストなどを使用し、ビンに複数のデータが入るようにすれば解決可能  
    なお、分布数え上げソートは、連結リストを使用せずに重複したキーをソート可能
2. キーはある範囲に収まる整数でなければならない（実用上、その範囲はかなり狭い必要有）：  
    分布数え上げソートも同様の制約を受ける．基数ソートアルゴリズムでは、この制約を逃れることが可能
