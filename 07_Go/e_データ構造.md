# データ構造

## 配列

添え字は0から始まる

```go
// 宣言方法
var 変数名 [長さ]型
var 変数名 [長さ]型 = [大きさ]型{初期値1, 初期値n}
変数名 := [...]型{初期値１, 初期値n}
```

## Slices

可変長配列のようなもの。初期化されていない場合は`nil`になる

配列の宣言と違って、スライスは `[ ]` の中に大きさを指定しない

==スライスは配列への「参照型」==で値を持つため、配列から部分列を取り出して `（スライス操作）` スライスを作成することが可能

```go
var 変数名 []型
var 変数名 []型 = []型{初期値1, ..., 初期値n} 
変数名 := 配列[start:end]		//配列(またはスライス)のstartから(end - 1)を取り出してスライスを作成
```

組み込み関数の `make()` を利用することで定義できる

```go
make([]型, len, cap)

func main() {
     a := make([]int,5, 5)
     fmt.Println(a) //=> [0 0 0 0 0]
}
```

### スライス操作

スライス操作は元の配列への参照を作っているので、変更などが元となる配列に影響してしまう

* `Slice[start:end]`：start から end - 1 まで
* `Slice[start:]`：start から最後尾まで
* `Slice[:end]`：先頭から end - 1 まで
* `Slice[:]`：先頭から最後尾まで

### 要素の追加

`newSlice := append(slice, "Ruby")`の形で、新しいスライスを作るしかない

### スライス同士の代入

型が同じであれば代入できる。同じアドレスを利用することになる(影響し合うことに)

### その他

* `len(スライス)`：要素の数
* `cap(スライス)`：スライスの最初の要素から数えて、元となる配列の要素数

## Map

初期化されていない場合は`nil`になる

### 宣言方法

```go
// 組み込み関数make()を利用して宣言
var aMap = make(map[キーの型]値の型, バッファの大きさ)
var aMap = make(map[キーの型]値の型)	// バッファの大きさは省略可能

// 初期値を指定して宣言
var 変数名 map[key]value = map[key]value{key1: value1, key2: value2, ..., keyN: valueN}
```

### 操作

```go
// 代入、追加
map[key] = elem
// 値の取得
map[key]
// 削除
delete(mapの変数, key)
```

## Range

`range` は、`Slices(スライス)` や、`Maps(マップ)` をひとつずつ反復処理するために使われる

indexやvalueを使わない場合は、変数名を`_`にすることで明示できる

```go
for index, value := range aSlice {
	fmt.Println(index, value)
}
```

