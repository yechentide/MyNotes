# 簡単文法

## 参考サイト

[Golang 入門](https://qiita.com/y-kaanai/items/e022b7c316cd8a6bb6d2)

[【Go】基本文法](https://qiita.com/k-penguin-sato/items/1d0e1c6b4bf937996cd3)

## 基本文法

### パッケージ、import

```go
package main

import (
    "fmt"
    "math/rand"
)

func main() {
  fmt.Println("My favorite number is", rand.Intn(10)) // => My favorite number is 1
}
```

個別にimportしても大丈夫

```go
import "fmt"
import "math/rand"
```

### Exported names

Goでは最初の文字が大文字で始まるものは、外部パッケージから参照できる`Exported names`

例えば以下の`Pi`は`mathパッケージ`からエクスポートされたもの

```shell
func main() {
   fmt.Println(math.Pi) //=> 3.141592653589793
}
```

### 定数

`const`キーワードを使用して宣言する

定数は、`文字(character)`、`文字列(string)`、`boolean`、`数値(numeric)`のみで使える

==定数は`:=`を使用して宣言することはできない==

### 変数

`var`キーワードで宣言する

複数の変数の後に型を書くことで複数の変数を同時に定義できる

初期値が与えられている場合、変数の型宣言は必要ない

初期化されてない場合、数値型は0、真理型はfalse、文字列型は空文字列になる

```go
var num int
var var1, var2, var3 bool

var str = "Go Programming Language"
var num = 2

var str, num, bool = "Go language", 23, true
```

関数内では`:=`を使った変数宣言もできる

```go
func main(){
   str := "Hello World"
   fmt.Println(str) //=> Hello World
}
```

### 型

`int uint uintptr`型は、OSによって32ビットか64ビットになる

* 真理型：`bool`

* 文字列型：`string`

* 整数型：`int  int8  int16  int32  int64 uint uint8 uint16 uint32 uint64 uintptr`

* 小数型：`float32 float64`

* その他：

    ```go
    byte	// uint8 の別名
    rune	// int32 の別名。Unicode のコードポイントを表す
    complex64
    complex128
    ```

==Goでは暗黙的な型変換は許されていない==

型を変換するときには、`型名(変換したい値)`で変換を行う

### 関数

関数は `０〜複数` の引数を取ることができる

引数の後, 戻り値の値に型名を書く必要がある

```go
func  <関数名>([引数]) [戻り値の型] {
    [関数の本体]
}

func margeString(s1 string, s2 string) string {
	return s1+s2
}
```

連続する引数が同じ型の場合は、引数の型の省略ができる

```go
func add(x, y int) int {
    return x + y
}
```

複数の戻り値もあり得る

```go
func multipleArgs(arg1, arg2 string)(string, string){
    return arg2, arg1
}
```

## データ構造

### 配列

添え字は0から始まる

```go
// 宣言方法
var 変数名 [長さ]型
var 変数名 [長さ]型 = [大きさ]型{初期値1, 初期値n}
変数名 := [...]型{初期値１, 初期値n}
```

### Slices

可変長配列のようなもの。初期化されていない場合は`nil`になる

配列の宣言と違って、スライスは `[ ]` の中に大きさを指定しない

==スライスは配列への「参照型」==で値を持つため、配列から部分列を取り出して `（スライス操作）` スライスを作成することが可能

```go
var 変数名 []型
var 変数名 []型 = []型{初期値1, ..., 初期値n} 
変数名 := 配列[start:end]		//配列(またはスライス)のstartから(end - 1)を取り出してスライスを作成
```

組み込み関数の `make()` を利用することで定義できる

```go
make([]型, len, cap)

func main() {
     a := make([]int,5, 5)
     fmt.Println(a) //=> [0 0 0 0 0]
}
```

#### スライス操作

スライス操作は元の配列への参照を作っているので、変更などが元となる配列に影響してしまう

* `Slice[start:end]`：start から end - 1 まで
* `Slice[start:]`：start から最後尾まで
* `Slice[:end]`：先頭から end - 1 まで
* `Slice[:]`：先頭から最後尾まで

#### 要素の追加

`newSlice := append(slice, "Ruby")`の形で、新しいスライスを作るしかない

#### スライス同士の代入

型が同じであれば代入できる。同じアドレスを利用することになる(影響し合うことに)

### その他

* `len(スライス)`：要素の数
* `cap(スライス)`：スライスの最初の要素から数えて、元となる配列の要素数

## 制御構文

### For

初期化ステートメントでは、短い変数宣言はよく利用される

 `()` は必要ないが `{}` は必要

真ん中の終了条件式以外は省略可能(`;`も省略可能)

```go
for i := 0; i < 10; i++ {
    sum += i
    fmt.Println(sum)  //=> 0 1 3 6 10
}

var i = 10
for i > 3 {
	fmt.Println(i)
	i--
}
```

### If

`for` と同様に `()` は必要ないが `{}` は必要

条件の前に、評価するための簡単なステートメントを書ける（ここで宣言された変数は、 `if` のスコープ内だけで有効）

```go
func condition(arg string)string{
	if v := "GO"; arg == v {
		return "This is Golang"
	}else{
		return "This is not Golang"
	}
}
```

### Switch

選択された case だけを実行してそれに続く全ての case は実行されない

```go
lang := "Go"
switch lang {
case "Ruby":
	fmt.Println("This is Ruby")
case "Go":
	fmt.Println("This is Go")
default:
	fmt.Println("This is a programming language")
}
// => This is Go
```

`switch`の右に何も条件を書かない場合は`switch true`と書くのと同じ

`if`文をよりシンプルに書ける

```go
lang := "Go"
switch {
case lang == "Ruby":
	fmt.Println("This is Ruby")
case lang == "Go":
	fmt.Println("This is Go")
default:
	fmt.Println("This is a programming language")
}
// => This is Go
```

### Defer（遅延実行）

defer文を定義すれば、関数を抜ける前に必ず実行される
中断処理やエラーハンドリング処理などで有効

一つの関数内で複数のdefer文を定義できる
後から定義したものから順に実行される

```go
func main(){
    defer fmt.Println("Golang") //defer1
    defer fmt.Println("Ruby") //defer2
    fmt.Println("JS") 
    //=> JS
    //=> Ruby
    //=> Golang
}
```

## ポインタ

### 変数アドレス

変数名の前に`&`をつける

### ポインタ型

型名の前に`*`をつける。アドレスを保存するような変数

初期化されていなければ、`nil`となる

```go
var var2 *int = &var1
```

## 構造体

Goにはオブジェクト指向言語におけるclassというものは存在しない

似た役割として関連する情報をひとまとめにする `struct（構造体）` が使用される

### 定義

```go
type Person struct {
   firstName string 
   age int
}
```

### 初期化

1. 変数定義後にフィールドを設定する方法

    ```go
    func main(){
    	var mike Person
    	mike.firstName = "Mike"
    	mike.age = 20
    	fmt.Println(mike.firstName, mike.age) //=> Mike 20
    }
    ```

2. `{}` で順番にフィールドの値を渡す方法

    ```go
    func main(){
    	bob := Person{"Bob", 30}
    	fmt.Println(bob.firstName, bob.age) //=>Bob 30
    }
    ```

3. フィールド名を `：` で指定する方法

    ```go
    func main(){
    	sam := Person{age: 15, firstName: "Sam"}
    	fmt.Println(sam.firstName, sam.age) //=>Sam 15
    }
    ```

4. コンストラクタ

    ```go
    func newPerson(firstName string, age int) *Person{
    	p := new(Person)
    	p.firstName = firstName
    	p.age = age
    	return p
    }
    func main(){
    	var jen *Person = newPerson("Jennifer", 40)
    	fmt.Println(jen.firstName, jen.age) //=>Jennifer 40
    }
    ```

### フィールド

ポインタを通してアクセスできる

```go
func main() {
	tim := Person{"Tim", 25}
    person1 := &tim			// person1は、*Person型
    (*person1).age = 25
    person1.age = 53 		//shortcutでp.Xと書くことも出来る
    fmt.Println(person1) 	//=> {Tim 53}
}
```

### メソッド

普通の関数と違うのはレシーバ引数の部分だけ

```go
func (<レシーバ引数>) <関数名>([引数]) [戻り値の型] {
	[関数の本体]
}
func (p Person) intro(greetings string) string{
    return greetings + " I am " + p.firstName
}
```

### 構造体の埋め込み

継承と似たような機能

```go
package main 
import "fmt"

type Person struct {
   firstName string 
}
func (a Person) name() string{ //Personのメソッド
    return a.firstName
}

type User struct {
     Person
}
func (a User) name() string { //Userのメソッド
    return a.firstName
}

func main(){
  bob := Person{"Bob"}
  mike := User{}
  mike.firstName = "Mike"

  fmt.Println(bob.name()) //=> Bob
  fmt.Println(mike.name()) //=> Mike
}
```



















