# 基本的な探索

## 探索(searching)

探索とは、n個のデータが登録されている表の中からある特定の値を持つデータを探し出す操作である。

探索は、最も頻繁に利用されるアルゴリズムの1つである。

表に格納する1つ1つのデータはレコード構造(record structure)となっている。

このレコード構造は、1個以上のフィールド(field)を持っている。

これらのフィールドのうち、ある特定のフィールドが探索の対象となる時、それをキー(key)と呼ぶ。

探索は次の3つの機能から構成される：

1. 探索「与えられたキーをもつデータを表から探し出す」
2. 挿入「データを表に登録する」
3. 削除「データを表から取り除く」

## 線形探索(linear search)

### 計算量

O(1)  <  O(log n)  <  ==O(n)==  <  O(nlog n)  <  O(n^整数^)  <  O(整数^n^)

### 説明

配列に登録されたデータを先頭から順に調べていく方法である。

探索は、配列の先頭から1つ1つ要素を比較していき、目的のデータを探し出す。

また、表を実現するデータ構造として、連結リストを使うこともできる。

最良の場合は1回目で目的のキーが見つかるが、最悪の場合はキーが見つからないので、n回実行される。

## 二分探索(binary search)

### 計算量

O(1)  <  ==O(log n)==  <  O(n)  <  O(nlog n)  <  O(n^整数^)  <  O(整数^n^)

### 説明

あらかじめキーの昇順（または降順）に整列されている配列の中から、特定のキーを持つデータを探し出すアルゴリズムである。

昇順の場合：

1. 探し出したいキーxを、配列の中央の要素のキーyと比較。x=yならば終了
2. x<yなら、探索範囲を左半分にして、探索を繰り返す
3. x>yなら、探索範囲を右半分にして、探索を繰り返す

## ハッシュ法(hashing)

ハッシュ法は、データの量にかかわらず挿入、探索、削除の操作を実質的にO(1)で行える優れたアルゴリズムである。

キーの値をデータが格納される位置（配列の添え字の値）に関連づける。

### 原理

ハッシュ関数h(x)を使って、キーの値をもとにして、配列にデータを絡納できる。

データを格納する配列をハッシュ表(hash table)と呼び、ハッシュ表の各要素をバケット(bucket)と呼ぶ。

キーの値からハッシュ関数を用いてハッシュ値を求めて、ある特定のバケットに結びつけることによって、高速な探索を実現するのがハッシュ法である。 

計算量がO(1)のハッシュ関数を用いれば、挿入、探索、削除をO(1)で行うことができる。

> ハッシュ関数(hash function)
>
> キーを配列の添え字へと変換する関数。戻り値をハッシュ値(hash value)という。

### ハッシュ値の衝突(collision)

異なったキーに対して同じハッシュ値が得られることを衝突、またはシノニム(synonym)という。

衝突が起きる場合、何らかの対策を施さなければハッシュ法は使いものにならない。

==すべてのバケットにできるだけ均等に振り分ける==ようなハッシュ関数を選ばなければならない。

バケットの数をB、登録するデータの数をN、各バケットには平均N/B個のデータが入ることとして、衝突対策を説明する。

### 衝突対策1：チェイン法

同じハッシュ値のデータを連結リストで繋ぐ方法である。

計算量：	探索O(1+N/B)、	挿入O(1+N/B)、	削除O(1+N/B)

データの個数Nに対してバケットの数Bが十分に大きければ、N/Bを定数と見なせるので、O(1+N/B) = O(1)

データの個数Nに対してバケットの数Bが小さい場合、O(1+N/B) = O(N)

### 衝突対策2：オープンアドレス法

衝突が発生したときに、再ハッシュ(rehashing)で別のバケットにデータを格納する方法。

もし、再ハッシュをB回（Bはバケットの個数）繰り返しても、空のバケットが見つからなければ、

ハッシュ表が満杯なので、これ以上データを登録することができなくなる。

==削除をする場合には、データを空にするのではなく、「削除済み」という状態を設定する。==

そして、探索を行うときに、「削除済み」のバケットがあれば、探索を継続することになる。

### ハッシュ関数

ハッシュ法では、均等なハッシュ値を発生するハッシュ関数が求められる。

 ここでいう「均等」とは、全てのキー値を対象としたときに、ハッシュ値が等確率で生成される（静的均等）だけでは不十分である。

 実際の使用にあたっては、全てのキー値が等確率で出現するわけではなく、キー値はかなり偏っているのが一般的である。

 そのため、実際にキーとして使われる値に対して、ハッシュ値が均等に振り分けられる（動的均等）ことが望まれる。

ハッシュ関数は、できるだけキーの全てのビットがハッシュ値に影響を与えるようにすべきである。

「キーの値を二乗してその中央をとる（平方採中法、middle-suqare method）」という方法は、かなり良好な結果が得られることが知られている。